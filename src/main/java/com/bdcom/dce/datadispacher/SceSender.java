package com.bdcom.dce.datadispacher;

import com.bdcom.dce.biz.pojo.Scenario;
import com.bdcom.dce.util.CommuniConstants;
import com.bdcom.dce.util.CommunicateStatus;
import com.bdcom.dce.util.logger.ErrorLogger;
import com.bdcom.dce.sys.AppSession;
import com.bdcom.dce.biz.scenario.ScenarioUtil;
import com.bdcom.dce.util.StringUtil;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * @author francis yuan <br>
 * E-mail: yuanjiajun@bdcom.com.cn <br>
 * @version 2012-12-3 <br>
 * Auto-Generated by eclipse Juno <br>
 */

public class SceSender implements
        CommunicateStatus, CommuniConstants {
	
	private InetAddress ip;
	
	private int port;
	
	static Socket server;
	
	public SceSender(InetAddress ip, int port) {
		this.ip = ip;
		this.port = port;
	}
	
	private int init() {
		int status = _NOT_DONE_YET;
		if (null == server) {
			 try {
//				server = new Socket(InetAddress.getLocalHost(),5768);
				server = new Socket(ip,port);
			} catch (UnknownHostException e) {
				String msg = this.getClass().getName() + 
						" throws UnknownHostException when portInfo Server ip: " +
						ip.toString() + "port: " +port;
				ErrorLogger.log(msg);
				status = _SERVER_INIT_FAILURE;
			} catch (IOException e) {
				String msg = this.getClass().getName() + 
						" throws IOException when portInfo Server ip: " +
						ip.toString() + "port: " + port;
				ErrorLogger.log(msg);
				status = _SERVER_INIT_FAILURE;
			} finally {
				if ( status < 0)
					return status;
			}
		 }
		 return status;
	 }

	public InetAddress getIp() {
		return ip;
	}

	public void setIp(InetAddress ip) {
		this.ip = ip;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}
	
	private void closeServer() {
		try {
			server.close();
		} catch (IOException e) {
			ErrorLogger.log(e.getMessage());
		}
		server = null;
	}
	
	public int sysncSces(Scenario[] sces, String flag) {
		
		int status = init();
		if ( status < 0) {
			return status;
		}
		
		BufferedReader in = null;
		PrintWriter out = null;
		try {
			in = new BufferedReader(
					 new InputStreamReader(server.getInputStream()));
			out = new PrintWriter(server.getOutputStream());
		} catch (IOException e) {
			ErrorLogger.log(e.getMessage());
			status = _SYNC_FAIL;
		} finally {
			if ( status < 0 ) {
				return status;
			}
		}
		
		out.println(flag);
		out.flush();
		if ( TERMINAL_FLAG.equals(flag) ) {
			
			
			String revStr = null;
			int timecounter = 0;
			while (true) {
				try {
					revStr = in.readLine();
				} catch (IOException e) {
					ErrorLogger.log(e.getMessage());
				}
				
				if (TERMINAL_FLAG.equals(revStr)) {
					closeServer();
					return 0;
				}
				
				try {
					TimeUnit.MICROSECONDS.sleep(200);
				} catch (InterruptedException e) {
					ErrorLogger.log(e.getMessage());
					// can be ignored, so no return here
					status = _LOCAL_INTERNAL_ERROR;
				} 
				timecounter++;
				if (timecounter > 10) {
					status = _TIME_OUT;
					closeServer();
					return status;
				}
			}
		}
		
		long[] hcodes = null;
		if ( null == sces ) {
			hcodes = new long[0];
		} else {
			hcodes = new long[sces.length];
		}
		
		Map<Long, Scenario> sceMap = new HashMap<Long,Scenario>();
		List<Long> hcodeList = new ArrayList<Long>();
		for ( int i=0; i < sces.length; i++ ) {
			hcodes[i] = sces[i].getHashCode();
			sceMap.put(new Long(hcodes[i]), sces[i]);
		}
		
		for ( long hcode : hcodes ) {
			out.println(String.valueOf(hcode));
		}
		out.println(END_FLAG);
		out.flush();
		
		int counter = 0;
		while (true) {
			String tmpStr = null;
			try {
				tmpStr = in.readLine();
			} catch (IOException e) {
				ErrorLogger.log(e.getMessage());
			} 
			
			if ( END_FLAG.equals(tmpStr) ) {
				break;
			}
			
			if ( StringUtil.isNotBlank(tmpStr) && 
					StringUtil.isValidNumber(tmpStr) ) {
				hcodeList.add(new Long(tmpStr));
			}
			counter ++;
			if ( counter > 10000 ) {
				break;
			}
		}
		
		if ( !hcodeList.isEmpty() ) {
			for ( Long hcode : hcodeList ) {
				Scenario sce = sceMap.get(hcode);
				String scename = sce.getScenarioName();
				String strToSend = getStrToSend(scename, scename);
				out.println(strToSend);
				Set<String> nameSet = sce.getAttrNames();
				for ( String name : nameSet ) {
					strToSend = getStrToSend(name,
							sce.getAttr(name)
							);
					out.println(strToSend);
				}
				out.println(SCE_FLAG);
				out.flush();
			}
		}
		out.println(END_FLAG);
		out.flush();
		
		counter = 0;
		int sceNum = 0;
		while (true) {
			String tmpStr = null;
			try {
				tmpStr = in.readLine();
			} catch (IOException e) {
				ErrorLogger.log(e.getMessage());
			} 
			
			if ( END_FLAG.equals(tmpStr) ) {
				break;
			}
			
			if ( StringUtil.isNotBlank(tmpStr) && 
					StringUtil.isValidNumber(tmpStr) ) {
				sceNum = Integer.parseInt(tmpStr);
			}
			counter ++;
			if ( counter > 100 ) {
				break;
			}
		}
		
		if ( sceNum > 0 ) {
			while ( true ) {
				Scenario sce = new Scenario();
				String tmpStr = null;
				while (true) {
					try {
						tmpStr = in.readLine();
					} catch (IOException e) {
						ErrorLogger.log(e.getMessage());
						continue;
					}
					if ( SCE_FLAG.equals(tmpStr) || END_FLAG.equals(tmpStr)) {
						break;
					}
					ScenarioUtil.wrapSce(tmpStr, sce);
				}
				if ( END_FLAG.equals(tmpStr) ) {
					break;
				} else {
					AppSession.addPreProvidedScenario(sce);
				}
			}
			AppSession.getMainFrame().refresh();
		}
		
		return _SYNC_SUCCESS;
	}
	
	private String getStrToSend(String key, String value) {
		StringBuffer sb = new StringBuffer();
		sb.append(key).append(SEPARATOR).append(value);
		
		return sb.toString();
	}
	
//	private byte[] getByte(Scenario sce) {
//		  byte[] bt=null;
//		  ByteArrayOutputStream baos=new ByteArrayOutputStream();
//		  
//		  try{
//			   if(sce!=null) {
//				  ObjectOutputStream  objos=new ObjectOutputStream(baos);
//				  objos.writeObject(sce);
//				  bt=baos.toByteArray();
//			   }
//		  } catch(IOException e){
//			   bt=(byte[])null;
//		  }
//		  return bt;
//	 }
//	
//	private Object restoreObj(byte[] bt) {
//		  Object obj = null;
//		  ObjectInputStream objIps;
//		  try {
//		      objIps = new ObjectInputStream(new ByteArrayInputStream(bt));
//		      obj = objIps.readObject();
//		  } catch (IOException e) {
//			   e.printStackTrace();
//		  } catch (ClassNotFoundException e) {
//			   e.printStackTrace();
//		  }
//		  return obj;
//	}
}
