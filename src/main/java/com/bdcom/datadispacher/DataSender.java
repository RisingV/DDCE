package com.bdcom.datadispacher;

import com.bdcom.util.log.ErrorLogger;
import com.bdcom.biz.pojo.BaseTestRecord;
import com.bdcom.biz.pojo.LoginAuth;
import com.bdcom.sys.AppSession;
import com.bdcom.util.StringUtil;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;

/**
 * @author francis yuan <br>
 * E-mail: yuanjiajun@bdcom.com.cn <br>
 * @version 2012-10-31 <br>
 * Auto-Generated by eclipse Juno <br>
 */

public class DataSender implements 
			CommunicateStatus, CommuniConstants{
	
	private static final String MAGIC_ID = "BDCOMNM2012";
	
	private static final String CLIENT_VERSION = "036";
	
	private InetAddress ip;
	
	private int port;
	
//	private SceSender sceSender;
	
	private ScenSender scenSender;
	
	private LocalTalker talker;
	
	private ScriptSender scriptSender;
	
	static Socket server;
	
	public DataSender(InetAddress ip, int port) {
		this.ip = ip;
		this.port = port;
//		scenSender = new ScenSender(ip, port+3);
		talker = new LocalTalker();
	}
	 
	private int init() {
		int status = _NOT_DONE_YET;
		if ( null == talker ) {
			talker = new LocalTalker();
		}
		if (null == server) {
			try {
//				server = new Socket(InetAddress.getLocalHost(),5768);
				server = new Socket(ip,port);
			} catch (UnknownHostException e) {
				String msg = this.getClass().getName() + 
						" throws UnknownHostException when portInfo Server ip: " +
						ip.toString() + "port: " +port;
				ErrorLogger.log(msg);
				status = _SERVER_INIT_FAILURE;
			} catch (IOException e) {
				String msg = this.getClass().getName() + 
						" throws IOException when portInfo Server ip: " +
						ip.toString() + "port: " + port;
				ErrorLogger.log(msg);
				status = _SERVER_INIT_FAILURE;
			} finally {
				if ( status < 0)
					return status;
			}
		 }
		 return status;
	 }
	
	public int sendRecord(BaseTestRecord record) {
		Map<String, String> kvMap = record.toKVSet();
		return sendData( kvMap, getSessionId() );
	}
	
	public void uploadScript() {
		if ( null == scriptSender) {
			scriptSender = new ScriptSender(ip, port + 1);
		}
		scriptSender.uploadScript();
	}
	
	public void downldScripts() {
		if ( null == scriptSender) {
			scriptSender = new ScriptSender(ip, port + 1);
		}
		scriptSender.downldScripts();
	}
	
	public void uploadScenarios() {
		if ( null == scenSender ) {
			scenSender = new ScenSender(ip, port+3);
		}
		scenSender.uploadScenarios();
	}

	public void downldScenarios() {
		if ( null == scenSender ) {
			scenSender = new ScenSender(ip, port+3);
		}
		scenSender.downldScenarios();
	}
	
	public int sendRecordWithTalk(BaseTestRecord record) {
		
			talker.init();
			String[] info = talker.getRemoteInfo();
			System.out.println(info[0] + info[1]);
			record.setFC(Boolean.parseBoolean(info[1]));
			Map<String, String> kvMap = record.toKVSet();
		//	int status = sendData( kvMap, info[0]);
			int status = sendData( kvMap, MAGIC_ID);
			kvMap.clear();
			kvMap.put(TERMINAL_NOLOGOUT_FLAG, TERMINAL_NOLOGOUT_FLAG);
			sendData( kvMap, MAGIC_ID);
//			int status = sendRecord(record);
			talker.sendResult( String.valueOf(status) );
			talker.closeClient();
			try {
				server.close();
			} catch (IOException e) {
			}
			ErrorLogger.recordData(record.toLogString());
			return status;
	}
	
	public int sendLoginAuth(LoginAuth loginAuth) {
		talker.start();
		Map<String, String> kvMap = new HashMap<String, String>();
		kvMap.put( loginAuth.getUserName(), 
				loginAuth.getUserPasswd() );
		return sendData(kvMap, getSessionId());
	}
	
	public void terminal() {
		Map<String, String> kvMap = new HashMap<String, String>();
		kvMap.put( TERMINAL_FLAG, TERMINAL_FLAG);
		sendData(kvMap, getSessionId() );
		if ( null != server) {
			try {
				server.close();
			} catch (IOException e) {
				ErrorLogger.log(e.getMessage());
			}
		}
		server = null;
//		sceSender.sysncSces(null, TERMINAL_FLAG);
//		sceSender = null;
		talker.terminalServer();
		talker = null;
	}
	 
	public int sendData(Map<String, String> kvMap, String sessionId) {
		int status = init();
		if ( status < 0) {
			return status;
		}
		
		BufferedReader in = null;
		PrintWriter out = null;
		try {
			in = new BufferedReader(
					 new InputStreamReader(server.getInputStream()));
			out = new PrintWriter(server.getOutputStream());
		} catch (IOException e) {
			ErrorLogger.log(e.getMessage());
			status = _SERVER_IO_FAILURE;
		} finally {
			if ( status < 0 ) {
				return status;
			}
		}
		 
		StringBuffer sb = new StringBuffer();
		for (Entry<String, String> kv : kvMap.entrySet()) {
			sb.append( kv.getKey() )
			  .append( SEPARATOR )
			  .append( kv.getValue() )
			  .append( SESSION_SPT )
			  .append( sessionId );
			String dataToSend = sb.toString();
			out.println(dataToSend);
			sb.delete( 0, sb.length() );
		}
				
		//send end flag to save data that has been sent
		out.println(END_FLAG);
		out.flush();
		int timecounter = 0;
		while (true) {
			String msg = null;
			try {
				msg = in.readLine();
			} catch (IOException e) {
				ErrorLogger.log(e.getMessage());
				status = _SERVER_IO_FAILURE;
			} finally {
				if ( status < 0 ) {
					return status;
				}
			}
			
			System.out.println(msg);
			
			if ( StringUtil.isNotBlank(msg) &&
					msg.startsWith(END_FLAG) ) {
				if ( status > _SUCCESS) {
					break;
				} else if (msg.length() > END_FLAG.length()) {
					int mergecode = Integer.parseInt(
							msg.substring(END_FLAG.length(), msg.length())
							); 
					status = _SUCCESS + mergecode;
					break;
				}
				status = _SUCCESS;
				break;
			}
			
			if ( AUTH_SUCCESS.equals(msg) ) {
				// to receive another END_FLAG to break
				status = _SUCCESS;
			}
			
			if ( (AUTH_SUCCESS + "1").equals(msg) ) {
				// to receive another END_FLAG to break
				status = _SUCCESS + 1;
			}
			
			if ( (AUTH_SUCCESS + "2").equals(msg) ) {
				// to receive another END_FLAG to break
				status = _SUCCESS + 2;
			}
			
			if ( INVALID_VER_MSG.equals(msg) ) {
				status = INVALID_CLIENT_VERSION;
				break;
			}
			
			if ( AUTH_FAIL.equals(msg) ) {
				status = _AUTH_FAIL;
				break;
			}
			 
			if ( INVAID_DATA.equals(msg) ) {
				status = _INVAILD_DATA;
				break;
			}
			
			try {
				TimeUnit.MICROSECONDS.sleep(200);
			} catch (InterruptedException e) {
				ErrorLogger.log(e.getMessage());
				// can be ignored, so no return here
				status = _LOCAL_INTERNAL_ERROR;
			} 
			timecounter++;
			if (timecounter > 10) {
				status = _TIME_OUT;
				break;
			}
		}

		return status;
	}
	
//	public int sysncSces(Scenario[] sces) {
//		return sceSender.sysncSces(sces, SYNC_FLAG);
//	}
	
	public void close() throws IOException {
		if ( null != server ) {
			server.close();
		}
	}
	
	private String getSessionId() {
		String sid = AppSession.getSessionId() + CLIENT_VERSION;
		return sid;
	}
	
}
