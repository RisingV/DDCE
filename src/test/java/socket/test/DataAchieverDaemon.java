package socket.test;

import socket.test.ext.BdcomSecurityAPI;
import socket.test.ext.BdcomSmtAPI;
import socket.test.ext.ISmtFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.text.ParseException;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author francis yuan <br>
 * E-mail: yuanjiajun@bdcom.com.cn <br>
 * @version 2012-10-30 5:46:43 <br>
 * Auto-Generated by eclipse Juno <br>
 */

public class DataAchieverDaemon implements Runnable, CommuniConstants {
	
	private int port;
	
	private ServerSocket server;
	
	private BdcomSmtAPI saver;
	
	private BdcomSecurityAPI authIndexer;
	
	private ISmtFactory isf;
	
	private static ExecutorService exec;

	static {
		exec = Executors.newCachedThreadPool();
	}
	
	public DataAchieverDaemon(int port) {
		this.port = port;
	}
	
	@Override
	public void run() {
		start();
	}
	
	public void setDataSaver(BdcomSmtAPI saver) {
		this.saver = saver;
	}
	
	public void setAuthIndexer(BdcomSecurityAPI authIndexer) {
		this.authIndexer = authIndexer;
	}
	
	public void setISmtFactory(ISmtFactory isf) {
		this.isf = isf;
	}

	public void start() {
	    Thread sceSyncThread = new Thread(getSceSyncThread(port+1, this));
		sceSyncThread.setDaemon(true);
		sceSyncThread.start();
		try {
			this.server = new ServerSocket(port);
			while(true) {
				Socket client = server.accept();
				exec.execute(getChildThread(client));
			}
		} catch (IOException e) {
		}
	}
	
	private Runnable getChildThread(final Socket client) {
		
		return new Runnable() {

			final private DataParser dataParser = new DataParser(saver, isf);
			
			final private Authenticator authenticator = new Authenticator(authIndexer);
			
			@Override
			public void run() {
				 try {
					BufferedReader in = new BufferedReader(
							 new InputStreamReader(client.getInputStream()));
					PrintWriter out=new PrintWriter(client.getOutputStream());
					
					boolean isErrorOcurred = false;
					boolean isloggedin = false;
					
					while (true) {
						
						 String revStr=in.readLine();
						 
						 System.out.println(revStr);
						 System.out.println("isErrorOcurred: "+isErrorOcurred);
						 System.out.println();
						 
						 if (revStr.startsWith(TERMINAL_FLAG)) {
							 Authenticator.logout(revStr);
//							 in.readLine();
							 break;
						 }
						 
						 if ( revStr.startsWith(TERMINAL_NOLOGOUT_FLAG) ) {
							 break;
						 }
						 
						 
						 if (END_FLAG.equals(revStr) ) {
							 if ( !isErrorOcurred && isloggedin) {
								 int status = dataParser.save();
								 out.println(END_FLAG + status);
								 out.flush();
							 } else {
								 dataParser.dumpData();
								 isErrorOcurred  = false;
							 }
							 continue;
						 }
						 
						 if ( Authenticator.isAuthorized(revStr) ) {
							 try {
								isloggedin  = true;
								dataParser.parse(revStr);
							} catch (ParseException e) {
								if ( !isErrorOcurred ) {
									isErrorOcurred = true;
									out.println(INVAID_DATA);
									out.flush();
								}
							}
						 } else {
							 int status = authenticator.authenticate(revStr);
							 if ( status > 0 ) {
								 isloggedin  = true;
								 out.println(AUTH_SUCCESS + status);
							 } else {
								 out.println(AUTH_FAIL);
							 }
							 out.flush();
						 }
						
					}
					
				} catch (IOException e) {
					throw new RuntimeException(
							"IOException occurs when handling client: " + 
							client.getRemoteSocketAddress());
				} finally {
					try {
						if ( null != client) {
							client.close();
						}
					} catch (IOException e) {
					}
				}
			}
			
		};
		
	}
	
	private Runnable getSceSyncThread(final int port, final DataAchieverDaemon ad) {
		return new Runnable() {
			private ServerSocket server;
			@Override
			public void run() {
				try {
					server = new ServerSocket(port);
					while(true) {
						Socket client = server.accept();
						exec.execute(ad.getSceSyncChildThread(client));
					}
				} catch (IOException e) {
				}
			}
		};
	}

	private Runnable getSceSyncChildThread(final Socket client) {
		return new Runnable() {
			
			private final SceManager sceManager = new SceManager();
			
			private final Set<Long> hcodeSetToGet = new LinkedHashSet<Long>();
			
			private final Set<Long> hcodeSetToSend = new LinkedHashSet<Long>();
	
			private Map<Long, PreProvidedScenario> h_preProvidedScenarios
								= new HashMap<Long, PreProvidedScenario>();
			
			@Override
			public void run() {
				
				BufferedReader in = null;
				PrintWriter out = null;
				try {
					in = new BufferedReader(
							 new InputStreamReader(client.getInputStream()) );
					out = new PrintWriter(client.getOutputStream());
				} catch (IOException e) {
				} 
				
				while ( true ) {
					String revStr = null;
					try {
						revStr = in.readLine();
					} catch (IOException e) {
						break;
					}
					
					if (revStr.startsWith(TERMINAL_FLAG)) {
						 out.println(TERMINAL_FLAG);
						 out.flush();
						 break;
					 }
					
					PreProvidedScenario[] sceArray = sceManager.getSceList();
					
					for ( int i = 0; i < sceArray.length; i++ ) {
						Long h = new Long(sceArray[i].getHashCode());
						System.out.println("server hcode :" + h);
						hcodeSetToSend.add( h );
						h_preProvidedScenarios.put(h, sceArray[i]);
					}
					
					
					while ( true ) {
						String tmpStr = null;
						try {
							tmpStr = in.readLine();
						} catch (IOException e) {
						}
						
						if ( END_FLAG.equals(tmpStr) ) {
							break;
						}
						
						if ( !isBlank(tmpStr) && isVaildNumber(tmpStr) ) {
							Long h = new Long(tmpStr);
							System.out.println("hcode :" + h);
							if (hcodeSetToSend.contains( h ) ) {
								hcodeSetToSend.remove(h);
							} else {
								hcodeSetToGet.add(h);
							}
							
						}
					}
					
					for ( Long hcode : hcodeSetToGet ) {
						out.println(String.valueOf(hcode));
					}
					out.println(END_FLAG);
					out.flush();
					while ( true ) {
						PreProvidedScenario sce = new PreProvidedScenario();
						String tmpStr = null;
						while (true) {
							try {
								tmpStr = in.readLine();
							} catch (IOException e) {
								e.printStackTrace();
								continue;
							}
							if ( SCE_FLAG.equals(tmpStr) || END_FLAG.equals(tmpStr)) {
								break;
							}
							sceManager.wrapSce(tmpStr, sce);
						}
						if ( END_FLAG.equals(tmpStr) ) {
							break;
						} else {
							sceManager.addPreProvidedScenario(sce);
						}
					}
					
					out.println(hcodeSetToSend.size());
					out.println(END_FLAG);
					out.flush();
					
					if ( !hcodeSetToSend.isEmpty() ) {
						for ( Long hcode : hcodeSetToSend ) {
							PreProvidedScenario sce = h_preProvidedScenarios.get(hcode);
							if ( null != sce ) {
								String scename = sce.getScenarioName();
								String strToSend = getStrToSend(scename, scename);
								System.out.println(strToSend);//to del
								out.println(strToSend);
								Set<String> nameSet = sce.getAttrNames();
								for ( String name : nameSet ) {
									strToSend = getStrToSend(name,
											sce.getAttr(name)
											);
									out.println(strToSend);
									System.out.println(strToSend);//to del
								}
								out.println(SCE_FLAG);
								out.flush();
							}
						}
					}
					out.println(END_FLAG);
					out.flush();
				}
			}
		};
	}
	
	private static boolean isVaildNumber(String num) {
		Pattern numberPattern = Pattern.compile("^\\d+$");
		Matcher numberMatcher = numberPattern.matcher(num);
		return numberMatcher.matches();
	}
	
	private static boolean isBlank(CharSequence cs) {
        int strLen;
        if (cs == null || (strLen = cs.length()) == 0) {
            return true;
        }
        for (int i = 0; i < strLen; i++) {
            if (Character.isWhitespace(cs.charAt(i)) == false) {
                return false;
            }
        }
        return true;
    }
	
	private String getStrToSend(String key, String value) {
		StringBuffer sb = new StringBuffer();
		sb.append(key).append(SEPARATOR).append(value);
		
		return sb.toString();
	}
//	private byte[] getByte(cenario sce) {
//		  byte[] bt=null;
//		  ByteArrayOutputStream baos=new ByteArrayOutputStream();
//		  
//		  try{
//			   if(sce!=null) {
//				  ObjectOutputStream  objos=new ObjectOutputStream(baos);
//				  objos.writeObject(sce);
//				  bt=baos.toByteArray();
//			   }
//		  } catch(IOException e){
//			   bt=(byte[])null;
//		  }
//		  return bt;
//	 }
//	
//	private Object restoreObj(byte[] bt) {
//		  Object obj = null;
//		  ObjectInputStream objIps;
//		  try {
//		      objIps = new ObjectInputStream(new ByteArrayInputStream(bt));
//		      obj = objIps.readObject();
//		  } catch (IOException e) {
//			   e.printStackTrace();
//		  } catch (ClassNotFoundException e) {
//			   e.printStackTrace();
//		  }
//		  return obj;
//	}
}
